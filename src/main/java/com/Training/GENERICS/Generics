Generics in Java :::

Generics are a facility of generic programming that were added to the Java programming
language in 2004 within J2SE 5.0. They allow "a type or method to operate on objects
of various types while providing compile-time type safety."[1] This feature specifies
the type of objects stored in a Java Collection.

Before generics, you had to cast every object you read from a collection.

Java has provided a safe alternative known as unbounded wildcard types. If
you want to use a generic type but you don’t know or care what the actual type
parameter is, you can use a question mark instead.

The following block of Java code illustrates a problem that exists when not using generics.
First, it declares an ArrayList of type Object. Then, it adds a String to the ArrayList.
Finally, it attempts to retrieve the added String and cast it to an Integer.

  List v = new ArrayList();
  v.add("test");
  Integer i = (Integer)v.get(0);        // Run time error

Although the code compiles without error, it throws a runtime exception
(java.lang.ClassCastException) when executing the third line of code.
This type of problem can be avoided by using generics and is the primary 
motivation for using generics.
Using generics, the above code fragment can be rewritten as follows:

  List<String> v = new ArrayList<String>();
  v.add("test");
  Integer i = v.get(0); // (type error)  Compile time error

The type parameter String within the angle brackets declares the ArrayList to be constituted
of String (a descendant of the ArrayList's generic Object constituents). 
With generics, it is no longer necessary to cast the third line to any particular type, 
because the result of v.get(0) is defined as String by the code generated by the compiler.

Compiling the third line of this fragment with J2SE 5.0 (or later) will yield a compile-time error
because the compiler will detect that v.get(0) returns String instead of Integer. 

arrays and generics do not mix well. 
For example, it is illegal to create an array of a generic type, a parameterized
type, or a type parameter. None of these array creation expressions are legal: new
List<E>[], new List<String>[], new E[]. All will result in generic array creation
errors at compile time.

//won't(WILL NOT) compile!
List<String>[] stringLists = new List<String>[1];

Note that you can’t primitive type as generic type: trying to create a
Stack<int> or Stack<double> will result in a compile-time error. This is a fundamental
limitation of Java’s generic type system. You can work around this
restriction by using boxed primitive types

There are some generic types that restrict the permissible values of their type
parameters. For example, consider java.util.concurrent.DelayQueue, whose
declaration looks like this:

class DelayQueue<E extends Delayed> implements BlockingQueue<E>;

The type parameter list (<E extends Delayed>) requires that the actual type
parameter E must be a subtype of java.util.concurrent.Delayed.

In summary, generic types are safer and easier to use than types that require
casts in client code.

Term 						Example						 Item
Parameterized type			 List<String> 				Item 23
Actual type parameter 		String					 	Item 23
Generic type 				List<E> 					Items 23, 26
Formal type parameter		 E 							Item 23
Unbounded wildcard type 	List<?> 					Item 23
Raw type 					List 						Item 23
Bounded type parameter 		<E extends Number>			 Item 26
Recursive type bound 		<T extends Comparable<T>>	 Item 27
Bounded wildcard type 		List<? extends Number> 		Item 28
Generic method static 		<E> List<E> asList(E[] a) 	Item 27
Type token 					String.class 				Item 29

One noteworthy feature of generic methods is that you needn’t specify the
value of the type parameter explicitly as you must when invoking generic constructors.
The compiler figures out the value of the type parameters by examining
the types of the method arguments. In the case of the program above, the compiler
sees that both arguments to union are of type Set<String>, so it knows that the
type parameter E must be String. This process is called type inference.

// Using a recursive type bound to express mutual comparability
public static <T extends Comparable<T>> T max(List<T> list) {...}

The type bound <T extends Comparable<T>> may be read as “for every type T
that can be compared to itself,”.

// Wildcard type for parameter that serves as an E producer
public void pushAll(Iterable<? extends E> src) {

// Wildcard type for parameter that serves as an E consumer
public void popAll(Collection<? super E> dst) {

PECS stands for producer-extends, consumer-super.

